import{_ as a,o as s,c as o,U as e}from"./chunks/framework.df9742f3.js";const C=JSON.parse('{"title":"Map和WeakMap","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/pre-knowledge/map.md","filePath":"blogs/pre-knowledge/map.md","lastUpdated":1701848741000}'),l={name:"blogs/pre-knowledge/map.md"},p=e(`<h1 id="map和weakmap" tabindex="-1">Map和WeakMap <a class="header-anchor" href="#map和weakmap" aria-label="Permalink to &quot;Map和WeakMap&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p><code>Map</code>是一种字典的数据结构，<code>Map</code> 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。一个<code>Map</code>对象在迭代时会根据对象中元素的插入顺序来进行。<code>Map</code>与普通对象最大的区别就是<code>Map</code>的<code>key</code>可以是任意类型的。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 最终会转成字符串 {[object Object]: 1}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(b</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> a)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// map的key就是对象a</span></span></code></pre></div><h2 id="map的特点" tabindex="-1">Map的特点 <a class="header-anchor" href="#map的特点" aria-label="Permalink to &quot;Map的特点&quot;">​</a></h2><ol><li>Map 默认情况下不包含任何键，所有键都是自己添加进去的。不同于 Object 原型链上有一些默认的键。</li><li>Map 的键可以是<strong>任意类型</strong>数据</li><li>Map 的键值对个数可以<strong>轻易</strong>通过<code>size</code>属性获取，Object 需要手动计算。</li><li>Map 在频繁增删键值对的场景下<strong>性能</strong>要比 Object 好。</li></ol><h2 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-label="Permalink to &quot;基本用法&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 实例化一个Map</span></span>
<span class="line"><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 添加值</span></span></code></pre></div><h2 id="常见属性和方法" tabindex="-1">常见属性和方法 <a class="header-anchor" href="#常见属性和方法" aria-label="Permalink to &quot;常见属性和方法&quot;">​</a></h2><ul><li>size: 返回 Map 结构的元素总数</li><li>set(key, value): 向 Map 中加入或更新键值对</li><li>get(key): 读取 key 对用的值，如果没有，返回 undefined</li><li>has(key): 判断某个键是否在 Map 对象中，在返回 true 否则返回 false</li><li>delete(key): 删除某个键，返回 true, 如果删除失败返回 false</li><li>clear(): 清空Map，删除所有元素</li></ul><p>遍历<code>Map</code>的方法</p><ul><li>keys()：返回<code>Map</code>的所有键名，是一个迭代器</li><li>values()：返回<code>Map</code>的所有的键值，是一个迭代器</li><li>entries()：返回所有成员的键值对，是一个迭代器</li><li>forEach()：遍历 Map 的所有成员</li></ul><h2 id="weakmap" tabindex="-1">WeakMap <a class="header-anchor" href="#weakmap" aria-label="Permalink to &quot;WeakMap&quot;">​</a></h2><blockquote><p>定义：WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的</p></blockquote><p>与<code>Map</code>的区别</p><ul><li><code>Map </code>的键可以是任意类型，<code>WeakMap </code>的键只能是对象类型(null除外)</li><li><code>WeakMap </code>键名所指向的对象，不计入垃圾回收机制</li><li><code>WeakMap</code>不可遍历，因为属性随时可能被回收，所以运行前后成员个数可能不一致。</li></ul><p><code>WeakMap</code> 的属性跟操作方法与 <code>Map</code> 一致，知识因为是弱引用，里面的属性随时会变动，所以 <code>WeakMap</code> 也没有遍历方法</p><p>要理解<code>WeakMap</code>，首先需要理解什么是强引用，什么是弱引用。</p><ul><li>强引用</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>如果我们熟悉<code>js</code>的垃圾回收机制就知道，当一个对象没有被任何其他内容引用时就会被回收。对于强引用来说，我们的<code>map</code>形成对<code>obj</code>这个对象的引用。此时对于<code>{}</code>这一块内存有<code>obj</code>和<code>map</code>两个引用，当我们设置<code>obj = null</code>时，<code>obj</code>已经断开了这块内存区间的引用，但是由于<code>map</code>是强引用的，所以<code>{}</code>这块内存区间不会被回收，除非我们主动设置<code>map.delete(obj)</code>。</p><ul><li>弱引用</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">WeakMap</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>弱引用我们可以理解为<code>js</code>的垃圾回收机制不会讲这个引用视为有效的引用。如果我们设置<code>obj = null</code>，那么对<code>{}</code>这块内存区域的引用次数就是1了，因为<code>map</code>时弱引用，所以可以不算。</p><blockquote><p>总的来说， <code>WeakMap</code> 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，<code>WeakMap</code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p></blockquote><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>弱引用可以方便<code>js</code>执行垃圾回收机制，防止开发者忘记手动解除依赖造成内存泄漏</li><li><code>Map、WeakMap</code>、都是一种集合的数据结构</li><li><code>Map 和 WeakMap</code> 是一种键值对的集合，<code>Map </code>的键可以是任意类型，<code>WeakMap </code>的键只能是除了<code>null</code>以外的对象类型</li><li><code>Map</code> 有遍历方法，<code> WeakMap</code> 属于弱引用不可遍历</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8" target="_blank" rel="noreferrer">https://zh.wikipedia.org/wiki/弱引用</a></p>`,29),n=[p];function c(t,r,d,i,y,D){return s(),o("div",null,n)}const F=a(l,[["render",c]]);export{C as __pageData,F as default};
